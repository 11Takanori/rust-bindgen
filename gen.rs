use io::WriterUtil;
use std::map;
use map::HashMap;

use syntax::ast;
use syntax::ast_util;
use syntax::ext::base;
use syntax::ext::build;
use syntax::parse;
use syntax::print::pprust;

use types::*;

struct GenCtx {
    ext_cx: base::ext_ctxt,
    mut unnamed_ty: uint,
    keywords: HashMap<~str, ()>
}

fn rust_id(ctx: &GenCtx, name: ~str) -> ~str {
    if ctx.keywords.contains_key(name) {
        return ~"_" + name;
    }
    return name;
}

fn unnamed_name(ctx: &GenCtx) -> ~str {
    ctx.unnamed_ty += 1;
    return fmt!("unnamed%u", ctx.unnamed_ty);
}

fn gen_rs(out: io::Writer, link: ~str, globs: ~[Global]) {
    let ctx = GenCtx { ext_cx: base::mk_ctxt(parse::new_parse_sess(None), ~[]),
                       mut unnamed_ty: 0,
                       keywords: syntax::parse::token::keyword_table()
                     };

    let mut fs = ~[];
    let mut gs = ~[];
    for globs.each |g| {
        match *g {
            GFunc(_) => fs.push(*g),
            _ => gs.push(*g)
        }
    }

    out.write_line(~"/* automatically generated by rust-bindgen */\n");
    out.write_line(~"use libc::*;\n");

    gs = remove_redundent_decl(gs);
    for gs.each |g| {
        let decl = match *g {
            GType(ti) => ctype_to_rsdecl(&ctx, ti.name, ti.typ),
            GCompDecl(ci) => if ci.cstruct {
                fmt!("type Struct_%s = c_void;", ci.name)
            } else {
                fmt!("type Union_%s = c_void;", ci.name)
            },
            GComp(ci) => if ci.cstruct {
                cstruct_to_rsdecl(&ctx, ci.name, ci.fields, false)
            } else {
                cunion_to_rsdecl(&ctx, ci.name, ci.fields, false)
            },
            GEnumDecl(ei) => fmt!("type Enum_%s = c_void;", ei.name),
            GEnum(ei) => cenum_to_rsdecl(&ctx, ei.name, ei.items, ei.kind, false),
            GVar(vi) => cvar_to_rsdecl(&ctx, vi.name, vi.typ),
            _ => { ~"" }
        };

        out.write_line(decl);
        out.write_line(~"");
    }

    out.write_line(fmt!("#[link_args=\"-l%s\"]", link));
    out.write_line(~"extern {\n");

    for fs.each |f| {
        match *f {
            GFunc(vi) => {
                let func = match *vi.typ {
                    TFunc(rty, aty, var) => cfunc_to_rsfunc(&ctx, vi.name, rty, aty, var),
                    _ => { ~"" }
                };
                out.write_line(func);
                out.write_line(~"");
            },
            _ => {}
        }
    }

    out.write_line("}");
}

fn remove_redundent_decl(gs: ~[Global]) -> ~[Global] {
    let mut ret = ~[];
    let mut pre = GOther;

    for gs.each |g| {
        match (pre, *g) {
            (GComp(ci1), GType(ti)) => match *ti.typ {
                TComp(ci2) => if !str::is_empty(ci1.name) {
                    ret.push(pre)
                },
                _ => ret.push(pre)
            },
            (GEnum(ei1), GType(ti)) => match *ti.typ {
                TEnum(ei2) => if !str::is_empty(ei1.name) {
                    ret.push(pre)
                },
                _ => ret.push(pre)
            },
            _ => ret.push(pre)
        }
        pre = *g;
    }

    ret.push(gs.last());

    return ret;
}

fn ctype_to_rsdecl(ctx: &GenCtx, name: ~str, ty: @Type) -> ~str {
    let rust_name = rust_id(ctx, name);

    return match *ty {
        TNamed(ti) => fmt!("type %s = %s;", rust_name, ti.name),
        TComp(ci) => if str::is_empty(ci.name) {
            if ci.cstruct {
                cstruct_to_rsdecl(ctx, name, ci.fields, true)
            } else {
                cunion_to_rsdecl(ctx, name, ci.fields, true)
            }
        } else {
            fmt!("type %s = %s;", rust_name, cty_to_rsty(ctx, ty))
        },
        TEnum(ei) => if str::is_empty(ei.name) {
            cenum_to_rsdecl(ctx, name, ei.items, ei.kind, true)
        } else {
            fmt!("type %s = %s;", rust_name, cty_to_rsty(ctx, ty))
        },
        _ => fmt!("type %s = %s;", rust_name, cty_to_rsty(ctx, ty))
    }
}

fn cstruct_to_rsdecl(ctx: &GenCtx, name: ~str, fields: ~[@FieldInfo], typedef: bool) -> ~str {
    let prefix = if typedef { ~"" } else { ~"Struct_" };
    let s_name = if str::is_empty(name) {
        unnamed_name(ctx)
    } else {
        name
    };

    let mut fs = ~"";
    let mut unnamed = 0;
    for fields.eachi |i, f| {
        let f_name = if str::is_empty(f.name) {
            unnamed += 1;
            fmt!("unnamed_field%u", unnamed)
        } else {
            rust_id(ctx, f.name)
        };

        let f_ty = cty_to_rsty(ctx, f.typ);
        let pre = if i > 0 { ~",\n" } else { ~"" };

        fs += fmt!("%s    %s: %s", pre, f_name, f_ty);
    }

    return fmt!("struct %s%s {\n%s\n}", prefix, rust_id(ctx, s_name), fs);
}

fn cunion_to_rsdecl(ctx: &GenCtx, name: ~str, _fields: ~[@FieldInfo], typedef: bool) -> ~str {
    let prefix = if typedef { ~"" } else { ~"Union_" };
    let u_name = if str::is_empty(name) {
        unnamed_name(ctx)
    } else {
        name
    };

    return fmt!("type %s%s = c_void; /* FIXME: union type */", prefix, rust_id(ctx, u_name));
}

fn cenum_to_rsdecl(ctx: &GenCtx, name: ~str, items: ~[@EnumItem], kind: IKind, typedef: bool) -> ~str {
    let prefix = if typedef { ~"" } else { ~"Enum_" };
    let e_name = if str::is_empty(name) {
        unnamed_name(ctx)
    } else {
        name
    };

    let ty = match kind {
        IInt => { ~"c_int" },
        _ => { ~"c_uint" }
    };

    let mut its = ~"";
    for items.each |it| {
        its += fmt!("const %s: %s = %d;\n", rust_id(ctx, it.name), ty, it.val);
    }

    return fmt!("type %s%s = %s;\n%s", prefix, rust_id(ctx, e_name), ty, its);
}

fn cvar_to_rsdecl(ctx: &GenCtx, name: ~str, _ty: @Type) -> ~str {
    return fmt!("/* FIXME: global variable %s */", name);
}

fn cfunc_to_rsfunc(ctx: &GenCtx, name: ~str, rty: @Type, aty: ~[(~str, @Type)], var: bool) -> ~str {
    let ret = match *rty {
        TVoid => ~"",
        _ => fmt!(" -> %s", cty_to_rsty(ctx, rty))
    };

    let mut args = ~"";
    let mut unnamed = 0;
    for aty.eachi |i, arg| {
        let (n, t) = *arg;

        let arg_name = if str::is_empty(n) {
            unnamed += 1;
            fmt!("++arg%u", unnamed)
        } else {
            fmt!("++%s", rust_id(ctx, n))
        };

        let arg_ty = cty_to_rsty(ctx, t);
        let pre = if i > 0 { ~", " } else { ~"" };

        args += fmt!("%s%s: %s", pre, arg_name, arg_ty);
    }

    let suf = if var { ~" /* FIXME: variadic function */" } else { ~"" };

    return fmt!("fn %s(%s)%s;%s", rust_id(ctx, name), args, ret, suf);
}

fn cty_to_rsty(ctx: &GenCtx, ty: @Type) -> ~str {
    return match *ty {
        TVoid => ~"c_void",
        TInt(i) => match i {
            IBool => ~"c_int",
            ISChar => ~"c_schar",
            IUChar => ~"c_uchar",
            IInt => ~"c_int",
            IUInt => ~"c_uint",
            IShort => ~"c_short",
            IUShort => ~"c_ushort",
            ILong => ~"c_long",
            IULong => ~"c_ulong",
            ILongLong => ~"c_longlong",
            IULongLong => ~"c_ulonglong"
        },
        TFloat(f) => match f {
            FFloat => ~"c_float",
            FDouble => ~"c_double"
        },
        TPtr(t) => fmt!("*%s", cty_to_rsty(ctx, t)),
        TArray(t, s) => fmt!("[%s * %d]", cty_to_rsty(ctx, t), s),
        TFunc(_, _, _) => ~"*u8",
        TNamed(ti) => rust_id(ctx, ti.name),
        TComp(ci) => if ci.cstruct {
            fmt!("Struct_%s", ci.name)
        } else {
            fmt!("Union_%s", ci.name)
        },
        TEnum(ei) => fmt!("Enum_%s", ei.name)
    };
}
