/* automatically generated by rust-bindgen */


#![feature(const_fn)]
#![allow(non_snake_case)]


#[derive(Copy, Debug)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
pub const JSVAL_TAG_SHIFT: ::std::os::raw::c_uint = 47;
#[repr(u8)]
#[derive(Debug, Copy, Clone)]
pub enum JSValueType {
    JSVAL_TYPE_DOUBLE = 0,
    JSVAL_TYPE_INT32 = 1,
    JSVAL_TYPE_UNDEFINED = 2,
    JSVAL_TYPE_BOOLEAN = 3,
    JSVAL_TYPE_MAGIC = 4,
    JSVAL_TYPE_STRING = 5,
    JSVAL_TYPE_SYMBOL = 6,
    JSVAL_TYPE_NULL = 7,
    JSVAL_TYPE_OBJECT = 8,
    JSVAL_TYPE_UNKNOWN = 32,
    JSVAL_TYPE_MISSING = 33,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone)]
pub enum JSValueTag {
    JSVAL_TAG_MAX_DOUBLE = 131056,
    JSVAL_TAG_INT32 = 131057,
    JSVAL_TAG_UNDEFINED = 131058,
    JSVAL_TAG_STRING = 131061,
    JSVAL_TAG_SYMBOL = 131062,
    JSVAL_TAG_BOOLEAN = 131059,
    JSVAL_TAG_MAGIC = 131060,
    JSVAL_TAG_NULL = 131063,
    JSVAL_TAG_OBJECT = 131064,
}
#[repr(u64)]
#[derive(Debug, Copy, Clone)]
pub enum JSValueShiftedTag {
    JSVAL_SHIFTED_TAG_MAX_DOUBLE = 18444492278190833663,
    JSVAL_SHIFTED_TAG_INT32 = 18444633011384221696,
    JSVAL_SHIFTED_TAG_UNDEFINED = 18444773748872577024,
    JSVAL_SHIFTED_TAG_STRING = 18445195961337643008,
    JSVAL_SHIFTED_TAG_SYMBOL = 18445336698825998336,
    JSVAL_SHIFTED_TAG_BOOLEAN = 18444914486360932352,
    JSVAL_SHIFTED_TAG_MAGIC = 18445055223849287680,
    JSVAL_SHIFTED_TAG_NULL = 18445477436314353664,
    JSVAL_SHIFTED_TAG_OBJECT = 18445618173802708992,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone)]
pub enum JSWhyMagic {
    JS_ELEMENTS_HOLE = 0,
    JS_NO_ITER_VALUE = 1,
    JS_GENERATOR_CLOSING = 2,
    JS_NO_CONSTANT = 3,
    JS_THIS_POISON = 4,
    JS_ARG_POISON = 5,
    JS_SERIALIZE_NO_NODE = 6,
    JS_LAZY_ARGUMENTS = 7,
    JS_OPTIMIZED_ARGUMENTS = 8,
    JS_IS_CONSTRUCTING = 9,
    JS_OVERWRITTEN_CALLEE = 10,
    JS_BLOCK_NEEDS_CLONE = 11,
    JS_HASH_KEY_EMPTY = 12,
    JS_ION_ERROR = 13,
    JS_ION_BAILOUT = 14,
    JS_OPTIMIZED_OUT = 15,
    JS_UNINITIALIZED_LEXICAL = 16,
    JS_GENERIC_MAGIC = 17,
    JS_WHY_MAGIC_COUNT = 18,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout {
    pub asBits: __BindgenUnionField<u64>,
    pub debugView: __BindgenUnionField<jsval_layout_jsval_layout_opaque_hpp_unnamed_1>,
    pub s: __BindgenUnionField<jsval_layout_jsval_layout_opaque_hpp_unnamed_2>,
    pub asDouble: __BindgenUnionField<f64>,
    pub asPtr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub asWord: __BindgenUnionField<usize>,
    pub asUIntPtr: __BindgenUnionField<usize>,
    pub _bindgen_data_: u64,
}
impl jsval_layout {
    pub unsafe fn asBits(&mut self) -> *mut u64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn debugView(&mut self)
     -> *mut jsval_layout_jsval_layout_opaque_hpp_unnamed_1 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s(&mut self)
     -> *mut jsval_layout_jsval_layout_opaque_hpp_unnamed_2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asDouble(&mut self) -> *mut f64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asPtr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asWord(&mut self) -> *mut usize {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn asUIntPtr(&mut self) -> *mut usize {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for jsval_layout {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout() {
    assert_eq!(::std::mem::size_of::<jsval_layout>() , 8usize);
    assert_eq!(::std::mem::align_of::<jsval_layout>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_jsval_layout_opaque_hpp_unnamed_1 {
    pub _bitfield_1: u64,
}
impl jsval_layout_jsval_layout_opaque_hpp_unnamed_1 {
    pub fn set_payload47(&mut self, val: u32) {
        self._bitfield_1 &= !(((1 << (47u32 as u64)) - 1) << 0usize);
        self._bitfield_1 |= (val as u64) << 0usize;
    }
    pub fn set_tag(&mut self, val: u32) {
        self._bitfield_1 &= !(((1 << (17u32 as u64)) - 1) << 47usize);
        self._bitfield_1 |= (val as u64) << 47usize;
    }
    pub const fn new_bitfield_1(payload47: u32, tag: u32) -> u64 {
        0 | ((payload47 as u64) << 0u32) | ((tag as u64) << 47u32)
    }
}
impl ::std::clone::Clone for jsval_layout_jsval_layout_opaque_hpp_unnamed_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_jsval_layout_opaque_hpp_unnamed_1() {
    assert_eq!(::std::mem::size_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_1>()
               , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_jsval_layout_opaque_hpp_unnamed_2 {
    pub payload: jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3 {
    pub i32: __BindgenUnionField<i32>,
    pub u32: __BindgenUnionField<u32>,
    pub why: __BindgenUnionField<JSWhyMagic>,
    pub _bindgen_data_: u32,
}
impl jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3
 {
    pub unsafe fn i32(&mut self) -> *mut i32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn u32(&mut self) -> *mut u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn why(&mut self) -> *mut JSWhyMagic {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for
 jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3() {
    assert_eq!(::std::mem::size_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_2_jsval_layout_opaque_hpp_unnamed_3>()
               , 4usize);
}
impl ::std::clone::Clone for jsval_layout_jsval_layout_opaque_hpp_unnamed_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_jsval_layout_jsval_layout_opaque_hpp_unnamed_2() {
    assert_eq!(::std::mem::size_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_2>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<jsval_layout_jsval_layout_opaque_hpp_unnamed_2>()
               , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value {
    pub data: jsval_layout,
}
impl ::std::clone::Clone for Value {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 8usize);
    assert_eq!(::std::mem::align_of::<Value>() , 8usize);
}
